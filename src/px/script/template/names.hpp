// Copyright (c) 2023.

//
// Created by pyxiion on 12.12.23.
//

#ifndef PX_ENGINE_NAMES_HPP
#define PX_ENGINE_NAMES_HPP
#include <string>
#include <string_view>
#include <cstdint>
#include <px/templates.hpp>
#include "px/utils/static_warning.hpp"

namespace px::script {
  namespace priv {
    template<class T>
    concept HasAsName = requires {
      { T::angelScriptClassName } -> std::convertible_to<std::string_view>;
    };

    template<class T>
    concept HasAsPtrName = requires {
      { T::angelScriptPtrClassName } -> std::convertible_to<std::string_view>;
    };
  } // priv

  template<class T>
  std::string getTypeBaseAsName() {
    using namespace priv;
    if constexpr (HasAsName<T>) {
      return std::string(T::angelScriptClassName);
    }
    if constexpr (px::is_base_of_template_v<std::shared_ptr, T>) {
      typedef typename T::element_type Type;
      if constexpr (HasAsPtrName<Type>) {
        return std::string(Type::angelScriptPtrClassName);
      } else {
        static_assert(HasAsName<Type>, "Unknown type name.");
        PX_STATIC_WARNING(false, "Using autogenerated type name for a smart ptr type.");
        return std::string(Type::angelScriptClassName) + "Ptr";
      }
    }
  }

  template<px::string_literal NAME>
  struct AsClassType {
  private:
    template<class>
    friend std::string getTypeBaseAsName();
    inline static constexpr std::string_view angelScriptClassName = NAME.value;
  };

  template<px::string_literal NAME>
  struct AsClassPtrType {
  private:
    template<class>
    friend std::string getTypeBaseAsName();
    inline static constexpr std::string_view angelScriptPtrClassName = NAME.value;
  };

#define PX_TYPE(cppType, asTypeName)                            \
  template<>                                                    \
  inline std::string getTypeBaseAsName<cppType>() {             \
    return asTypeName;                                          \
  }

  PX_TYPE(void,       "void")

  PX_TYPE(int8_t,     "int8")
  PX_TYPE(uint8_t,   "uint8")

  PX_TYPE(int16_t,    "int16")
  PX_TYPE(uint16_t,  "uint16")

  PX_TYPE(int32_t,    "int")
  PX_TYPE(uint32_t,  "uint")

  PX_TYPE(int64_t,    "int64")
  PX_TYPE(uint64_t,  "uint64")

  PX_TYPE(float,      "float")
  PX_TYPE(double,     "double")

  PX_TYPE(std::string,"string")

#undef PX_TYPE


  namespace priv {
    template<class T, bool isArg>
    struct GetTypeAsNameImpl {
      inline static std::string name = getTypeBaseAsName<T>();
    };

    template<class T>
    struct GetTypeAsNameImpl<T&, false> {
      inline static std::string name = getTypeBaseAsName<T>() + " &";
    };
    template<class T>
    struct GetTypeAsNameImpl<T&, true> {
      inline static std::string name = getTypeBaseAsName<T>() + " &in";
    };

    template<class T, bool isArg>
    struct GetTypeAsNameImpl<const T, isArg> {
      inline static std::string name = "const " + getTypeBaseAsName<T>();
    };

    template<class T>
    struct GetTypeAsNameImpl<const T &, false> {
      inline static std::string name = "const " + getTypeBaseAsName<T>() + " &";
    };
    template<class T>
    struct GetTypeAsNameImpl<const T &, true> {
      inline static std::string name = "const " + getTypeBaseAsName<T>() + " &in";
    };

    template<class T>
    struct GetTypeAsNameImpl<T *, true> {
      inline static std::string name = getTypeBaseAsName<T>() + " @";
    };

    template<class T>
    struct GetTypeAsNameImpl<const T *, true> {
      inline static std::string name = "const " + getTypeBaseAsName<T>() + " @";
    };
  } // priv

  template<class T, bool isArg = false>
  constexpr inline std::string_view getTypeAsName() {
    return priv::GetTypeAsNameImpl<T, isArg>::name;
  }

} // px::script

#endif //PX_ENGINE_NAMES_HPP
